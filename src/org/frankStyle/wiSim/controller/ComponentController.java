package org.frankStyle.wiSim.controller;

import java.awt.Point;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ListIterator;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.crimson.tree.XmlDocument;
import org.frankStyle.wiSim.WSNeditor;
import org.frankStyle.wiSim.model.ComponentRoot;
import org.frankStyle.wiSim.model.ComponentSensor;
import org.frankStyle.wiSim.model.ComponentSinkNode;
import org.frankStyle.wiSim.model.ComponentTargetNode;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;


/**
 * @author Arman
 * 
 */
public class ComponentController {
	Document document;
	private static ComponentRoot rootComponent;
	boolean m_bDirty;
	final static String tclPath = WSNeditor.projectPath +System.getProperty("file.separator")+ ".."+System.getProperty("file.separator")+"tclOut.tcl";
	final static String logFilePath = WSNeditor.projectPath +System.getProperty("file.separator")+System.getProperty("file.separator") +"log.txt";
	public final static double defaultSensorRadius = 50;

	public ComponentController() {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.newDocument(); // Create from whole cloth
			ComponentController.rootComponent = new ComponentRoot(document);
			setDirty(false);
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		} // buildDom
	}

	public Document getM_document() {
		return document;
	}

	public void saveTCL(String tcl) throws Exception {
		File f = new File(ComponentController.tclPath);
		FileOutputStream fout = new FileOutputStream(f);
		fout.flush();
		fout.write(tcl.getBytes());
		fout.close();

	}

	public ComponentRoot getRootComponent() {
		return ComponentController.rootComponent;
	}

	public boolean isM_bDirty() {
		return m_bDirty;
	}

	public static void setEnvironmentBound(double width, double height) {
		if (ComponentController.rootComponent != null) {
			ComponentController.rootComponent.getEnv().setWidth(width);
			ComponentController.rootComponent.getEnv().setHeight(height);
		} else
			System.err
					.print("rootComp is null couldnt change environment boundary");
	}

	public void clearDocument() {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.newDocument(); // Create from whole cloth
			ComponentController.rootComponent = new ComponentRoot(document);
			setDirty(false);
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		} // buildDom
	}

	public Document getXMLDocument() {
		return document;
	}

	public void outputXML(File file) {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.newDocument(); // Create from whole cloth
			XmlDocument xdoc = (XmlDocument) document;
			ComponentController.rootComponent.buildXMLDocument(xdoc);
			BufferedWriter writer = new BufferedWriter(new FileWriter(file));
			xdoc.write(writer);
			setDirty(false);
		} catch (IOException e) {
			System.out.println("OutputXML error");
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		} // buildDom
	}

	public void inputXML(File file) {
		ComponentController.rootComponent = null;
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.parse(file);

			ComponentController.rootComponent = new ComponentRoot(document);
			setDirty(false);
		} catch (SAXParseException spe) {
			// Error generated by the parser
			System.out.println("\n** Parsing error" + ", line "
					+ spe.getLineNumber() + ", uri " + spe.getSystemId());
			System.out.println("   " + spe.getMessage());

			// Use the contained exception, if any
			Exception x = spe;
			if (spe.getException() != null)
				x = spe.getException();
			x.printStackTrace();
		} catch (SAXException sxe) {
			// Error generated by this application
			// (or a parser-initialization error)
			Exception x = sxe;
			if (sxe.getException() != null)
				x = sxe.getException();
			x.printStackTrace();
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		} catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
		}
		JSimTclController.setJavaSimValid(false);
	}

	@Override
	public String toString() {
		return document.getNodeName();
	}

	public static ComponentRoot getRoot() {
		return ComponentController.rootComponent;
	}

	public void setRoot(ComponentRoot root) {
		ComponentController.rootComponent = root;
	}

	public void arrangeOnGrid(double gridSpace) {
		ListIterator<ComponentSensor> iter = ComponentController.rootComponent
				.sensorsIterator();
		// Vector<Point> locs=new Vector<Point>();

		int shift = (int) gridSpace / 2;
		while (iter.hasNext()) {
			ComponentSensor i = iter.next();
			int locX = (int) (((int) ((i.getLocation().getX() + shift) / gridSpace)) * gridSpace);
			int locY = (int) ((int) ((i.getLocation().getY() + shift) / gridSpace) * gridSpace);
			i.setLocation(new Point(locX, locY));
		}
		ListIterator<ComponentTargetNode> targets = ComponentController.rootComponent
				.targetsIterator();
		while (targets.hasNext()) {
			ComponentTargetNode target = targets.next();
			int locX = (int) (((int) ((target.getLocation().getX() + shift) / gridSpace)) * gridSpace);
			int locY = (int) (((int) ((target.getLocation().getY() + shift) / gridSpace)) * gridSpace);
			target.setLocation(new Point(locX, locY));
		}
		ComponentSinkNode sink = ComponentController.rootComponent
				.getSinkNode();
		int locX = (int) (((int) ((sink.getLocation().getX() + shift) / gridSpace)) * gridSpace);
		int locY = (int) (((int) ((sink.getLocation().getY() + shift) / gridSpace)) * gridSpace);
		sink.setLocation(new Point(locX, locY));
	}

	public void addSensor(ComponentSensor sensor) {
		ComponentController.rootComponent.addSensorNode(sensor);
	}

	public void addTarget(ComponentTargetNode target) {
		ComponentController.rootComponent.addTargetNode(target);
	}

	public void removeSensor(ComponentSensor sensor) {
		ComponentController.rootComponent.removeSensorNode(sensor);
	}

	public void removeTarget(ComponentTargetNode target) {
		ComponentController.rootComponent.removeTargetNode(target);
	}

	public boolean isDirty() {
		return m_bDirty;
	}

	public void setDirty(boolean bDirty) {
		m_bDirty = bDirty;
	}

}
